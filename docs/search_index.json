[["functions.html", "19 Writing Your Own Functions 19.1 Objectives 19.2 Additional reading 19.3 Why write your own functions? 19.4 How do functions work? 19.5 Documenting functions 19.6 Error handling", " 19 Writing Your Own Functions 19.1 Objectives Understand when custom functions are useful Build simple custom functions with multiple arguments Efficiently handle potential errors when writing functions and loops 19.2 Additional reading Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. R for Data Science (2e). Chapter 25: Functions. Available: https://r4ds.hadley.nz/functions.html Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. R for Data Science (2e). Chapter 16: Function documentation. Available: https://r-pkgs.org/man.html 19.3 Why write your own functions? We have used a lot of different functions in this class already. Some are built into R, like mean(), and some come with packages, like mutate() in tidyverse. It might feel like there are already an almost-infinite number of functions out there. Why would you ever need to write your own? A few reasons: Much like loops, functions can help automate a repeating task. If you have a series of functions that you often use in order, combining them into a single function can be useful. Instead of copying and pasting sections of code, you can write and modify a single function, all at once, making it less likely that you will have an error in one of your many copy-paste replicates. Functions can exist in a separate file for you to load later. This is especially useful if they are long and complex; unlike a loop, you don’t have to take up space in your working code with a long series of data processing or modeling tasks. You can also use the same function in multiple projects. You can share code for just a function with a colleague, instead of having to send them your entire script to show how to get one task done. 19.4 How do functions work? You’ve been on the “user” end of functions many times, so you know that they have a name, they take a series of arguments as input, and they give you an output. Beyond that, there’s not much to know. This is the basic structure of a function: name &lt;- function(arugments){ output &lt;- code return(output) } We would then use this function like this: name(arguments). For example, for some reason there is no function built into R to calculate the mode (i.e., the most common element in a vector/series). (mode() tells you the internal storage mode of an object, not the value that occurs the most often.) I could write a function that does that: mode_calc &lt;- function(vect){ unique_vals &lt;- unique(vect) #Get unique values in the vector value_counts &lt;- tabulate(vect) #Count the number of occurrence of each value max_count &lt;- max(value_counts) #Identify the max number of occurrence mode &lt;- unique_vals[which(value_counts == max_count)] #Identify the unique value(s) that have the max number of occurrences return(mode) } If we test this: test_values &lt;- c(1, 1, 1, 2, 2, 2, 2) modal_value &lt;- mode_calc(test_values) modal_value ## [1] 2 Functions can also take multiple arguments. For example, we might want to be able to remove NAs from the function with an na.rm argument like we have in mean() and median(), so that with the presence of any NA values, the function returns NA: mode_calc2 &lt;- function(vect, na.rm){ if(na.rm == FALSE &amp; any(is.na(vect))) return(NA) #Return NA if needed unique_vals &lt;- unique(vect) #Get unique values in the vector value_counts &lt;- tabulate(vect) #Count the number of occurrence of each value max_count &lt;- max(value_counts) #Identify the max number of occurrence mode &lt;- unique_vals[which(value_counts == max_count)] #Identify the unique value(s) that have the max number of occurrences return(mode) } test_values &lt;- c(1, 1, 1, 2, 2, 2, 2, NA) modal_value &lt;- mode_calc2(test_values, na.rm = FALSE) modal_value ## [1] NA modal_value &lt;- mode_calc2(test_values, na.rm = TRUE) modal_value ## [1] 2 Finally, you can also provide defaults to function arguments, which are specified just like you see them on the help pages of other functions. We did not specify a default for either vect or na.rm in our mode_calc2 function. This means that the function will throw an error if we fail to specify either argument: modal_value &lt;- mode_calc2(test_values) ## Error in mode_calc2(test_values): argument &quot;na.rm&quot; is missing, with no default We can fix this but providing a default value: mode_calc2 &lt;- function(vect, na.rm = FALSE){ ... } Although functions can take multiple arguments, they can only produce a single output. If you want multiple pieces of information, you will have to combine them into a single argument, whether that’s a data frame, a vector, or a list. The output of a function is specified within return(). This isn’t strictly required, but otherwise the function will output whatever it last ran, which is not always what you want (see the na.rm example above). 19.5 Documenting functions It’s a good idea to define the arguments and outputs of functions for your future self and any other future users. You can do this with comments or with a special documentation called “roxygen”, which package developers use. Roxygen comment lines always start with #’ , (the usual # for a comment, followed immediately by a single quote ’). They are nice because they create automatic highlighting and text colors, but also because you can use them to create actual help pages, if you want to! (See the “Additional reading” section above.) Whether you use roxygen or not, you want to define: The purpose of the function (“Description” under the help pages) The function arguments The function’s outputs Any useful examples Again, with our mode_calc function: #&#39; Determine the mode of a vector #&#39; #&#39; @param vect A vector (numeric, integer, character, date, or factor) #&#39; @param na.rm Logical; remove NAs? #&#39; @returns A vector of the same type as vect #&#39; @examples #&#39; mode_calc2(c(1,1,2), na.rm = TRUE) mode_calc2 &lt;- function(vect, na.rm = FALSE){ if(na.rm == FALSE &amp; any(is.na(vect))) return(NA) #Return NA if needed unique_vals &lt;- unique(vect) #Get unique values in the vector value_counts &lt;- tabulate(vect) #Count the number of occurrence of each value max_count &lt;- max(value_counts) #Identify the max number of occurrence mode &lt;- unique_vals[which(value_counts == max_count)] #Identify the unique value(s) that have the max number of occurrences return(mode) } 19.6 Error handling In both loops and functions (and maybe even more so in loops), you will sometimes end up with arguments that just don’t work and need an error or warning. In a loop, this can be frustrating because the loop will quit partway through, just when you walked away to let your code run for a while. We are accustomed to using functions that show error and warning messages; for example, if we provide a character vector to mean(): mean(c(&quot;this&quot;,&quot;is&quot;,&quot;a&quot;,&quot;character&quot;,&quot;vector&quot;)) ## Warning in mean.default(c(&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;character&quot;, &quot;vector&quot;)): argument ## is not numeric or logical: returning NA ## [1] NA We can make this happen for our own functions, too. For example, the tabulate function, doesn’t work well on numeric vectors of length 1 because it assumes we want a sequence of numbers of that length. We can warn users about this using the warning() function: mode_calc2 &lt;- function(vect, na.rm = FALSE){ if(length(vect)==1){ warning(&quot;Vector has length 1; results may be unexpected&quot;) } if(na.rm == FALSE &amp; any(is.na(vect))) return(NA) #Return NA if needed unique_vals &lt;- unique(vect) #Get unique values in the vector value_counts &lt;- tabulate(vect) #Count the number of occurrence of each value max_count &lt;- max(value_counts) #Identify the max number of occurrence mode &lt;- unique_vals[which(value_counts == max_count)] #Identify the unique value(s) that have the max number of occurrences return(mode) } mode_calc2(10) ## Warning in mode_calc2(10): Vector has length 1; results may be unexpected ## [1] NA Alternatively, we could make this an error using the stop() function: mode_calc2 &lt;- function(vect, na.rm = FALSE){ if(length(vect)==1){ stop(&quot;Vector has length 1; results may be unexpected&quot;) } if(na.rm == FALSE &amp; any(is.na(vect))) return(NA) #Return NA if needed unique_vals &lt;- unique(vect) #Get unique values in the vector value_counts &lt;- tabulate(vect) #Count the number of occurrence of each value max_count &lt;- max(value_counts) #Identify the max number of occurrence mode &lt;- unique_vals[which(value_counts == max_count)] #Identify the unique value(s) that have the max number of occurrences return(mode) } mode_calc2(10) ## Error in mode_calc2(10): Vector has length 1; results may be unexpected "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
