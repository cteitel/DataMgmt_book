# Version Control with Git and GitHub

```{r, fig.cap="Fairly accurate. (https://xkcd.com/1597/)", fig.align='center', out.width='80%', echo = FALSE, eval = TRUE}
knitr::include_graphics("https://imgs.xkcd.com/comics/git.png")
```

https://swcarpentry.github.io/git-novice
https://ecorepsci.github.io/reproducible-science/version-control-git.html 

## Objectives

* Understand the benefits and challenges of using Git for version control
* Modify, stage, and commit changes with Git
* Fetch and push code from/to a remote repository

## The what and why of version control

Git is a version control system. It tracks all the changes you make to your files and allows you to go back to previous versions as far back in time as you need. Git is useful for keeping yourself organized and can be combined with collaboration software (GitHub) to make sharing code and other files easy. You might have a folder that looks something like this:

![](images/files_with_dates.png)

My past self obviously could have been better about using consistent formatting for dates (some of these include year and some do not), but even if I had done so there are a few drawbacks to this approach:

* Each of these files takes up space on my hard drive. Even if each is very small, they will add up.
* I don't know what changes were made between each of these versions, so it would be hard for me to go back to an old version to find deleted or modified code.
* I can't be totally sure which of these is the most recent version. Sometimes, the "date modified" doesn't line up with the date on the file. What to do then?

Git provides a solution to this problem. Using Git, you will only have one file for each script on your computer, but you will have a log of changes, including your own notes on what you changed and why. For example:

![](images/git_commits.png)

You can also easily see the changes made at each stage:

![](images/git_changes.png)

Additional reading: https://swcarpentry.github.io/git-novice/01-basics.html

## Getting started with Git and GitHub

### Git

--> [Follow these instructions to install Git.](https://carpentries.github.io/workshop-template/install_instructions/#git)

### GitHub

GitHub extends Git for collaboration (including with yourself by syncing across your devices, if applicable). Two people can have the same repository on their computers, then sync these changes to the remote repository (called fetching/pulling and pushing). During this process, you can see what changes your collaborator made and identify and conflicts, for example where you edited the same code at the same time.

To make a GitHub account:

1. Go to https://github.com and follow the “Sign up” link at the top-right of the window.
2. Follow the instructions to create an account.
3. Verify your email address with GitHub.
4. Configure multifactor authentication. You can use Duo or any other authenicator app you already have.

### GitHub Desktop

As an easy on-ramp to using Git, we will use a graphical user interface (GUI) called GitHub Desktop. GUIs provide point-and-click interfaces. Most of the applications you use provide a GUI - you don't have to type in commands for them to work. In this lesson, we will use the GUI side-by-side with the command-line method so you can see which works best for you. The GUI is more limited in its functionality but a good place to get familiar with the principles of version control before moving on to more advanced applications.

--> [Download and install GitHub Desktop](https://desktop.github.com/download/)

## Basic Git structure and commands

![](images/git_schematic.png)

The central commands for using Git are:

* `git init`: Creates a new empty repository in your current directory
* `git add`: Sends a new or changed file in your working directory to the staging area
* `git commit`: Sends a staged file to the local repository

When using a remote repository on GitHub (or another platform, we add):

* `git push`: Sends changes from the local repository to the remote repository
* `git fetch`: Gets changes from the remote repository and compares them with the local repository (but does nothing to local files)
* `git pull`: Gets changes from the remote repository and makes the corresponding changes to local files

## Using Git in the command line

### The command line

You can use Git from the command line in the computer’s terminal. The command line can be intimidating if you haven’t used it before, but using Git only requires basic familiarity with it. Commands are slightly different between operating systems (Windows vs. Mac/Linux).

When you open up the terminal (or command prompt) on your computer, you’ll see a symbol, on many computers it is a “$” or “>”, followed by a blinking cursor. That symbol is called the prompt, and it means the terminal is waiting for your input. If you copy-paste any code from this chapter into your terminal, make sure you only copy the part after the prompt (don’t copy the >). Also, if Ctrl+V does not work in the terminal, you can right-click to paste (Cmd+V should work on a Mac).

When you open the terminal, you should automatically be located in the root directory of your file system (or your home directory, if you have a computer with multiple users). On a Mac, this will usually look like

```
COMPUTER-NAME: ~username$
```

And on Windows

```
C:\Users\username>
```

To move around directories we use the command `cd`, which stands for "change directory". For example, to move to the Research subfolder in my Documents folder, I might type in:

```{bash, eval = F}
cd Documents/Research
```

To go up a directory, use "..". The following command would take me back up to my Documents folder:

```{bash, eval = F}
cd ..
```

### Configuring Git (one time only)

On a command line, Git commands are written as `git` `verb` `options`, where `verb` is what we actually want to do and `options` is additional optional information which may be needed for the verb. To set up Git for the first time:

```{bash, eval = F}
git config --global user.name "My name"
git config --global user.email "myemail@uga.edu"
```

This user name and email will be associated with your subsequent Git activity, which means that any changes pushed to GitHub, BitBucket, GitLab or another Git host server will include this information. The email address used should be the same as the one used when setting up your GitHub account. There are more configuration options you can personalize, but we won’t get into that. If you want to check what configuration options you have active, you can use:

```{bash, eval = F}
git config --list
```

### Creating a repository (one time per project)

To create a repository (in other words, to put a directory under version control), we first have to navigate to that directory. Here, we will create a repository for this class.

```{bash, eval = F}
cd Documents/Classes/FANR8950_Fall2025
```

> A side note: if you have spaces in any of your directory names (for example, if your directories are in OneDrive), you will need to put the path in quotes. Otherwise, the terminal thinks those spaces indicate a new argument or command.

Now we will enable Git to start tracking everything inside this folder:

```{bash, eval = F}
git init
```

This command initializes Git. You won't immediately notice any changes in the directory, but if you show hidden files in your file explorer you will notice there is a new subfolder called .git. That folder is where Git will store all of its version control information. You don’t have to worry about the content of that folder.

### Staging files

Creating a repository enables Git to start tracking files within it, but that does not happen automatically. We have to tell Git which files we want to track. We can check what Git is tracking so far by using:

```{bash, eval = F}
git status 
```

At the bottom, we'll see a list of untracked files. We need to switch on tracking on those. To begin tracking a new file, we use the verb 'add'. For example, to track a file named "exercise2.R" we would type:

```{bash, eval = F}
git add exercise2.R
```

This works well if we want to add a specific file. If we want to start tracking the whole content of the folder, we can do:

```{bash, eval = F}
git add --all
```

### Ignoring files

Git is optimized to work with plain text files (for example .txt or R scripts), and it doesn't really understand binary files (which is how Word files and PDFs are stored, for example). Also, some files typically do not need to be version controlled, such as images; in fact, because they are large files, version controlling images can end up clogging your workflow. Make sure you are always aware of what exactly you're adding when you use 'git add --all'. When in doubt, add files one by one. We can set up some rules to exclude types of files or individual files that we don't want to track. Some rules of thumb:

* File encoding (plain-text vs. binary): Git cannot track changes within binary files, so, even though you **can** store these files under version control, you won't be able to use Git to compare different version, so there's really no point in tracking these;
* Code-generated: anything that can be reproduced by running code does not need to be version-controlled;
* Size: files that are too big will slow down the functioning of Git. As a benchmark, you can keep in mind the maximum size limit enforced by GitHub, which is 100 MB -- but if you follow the two criteria above, you will rarely end up with this problem because 100 MB's worth of plain-text files is a whole lot of plain text. 

You can create a text file called ".gitignore" in our repository by using your default text editor (Notepad for Windows, TextEdit for MacOS, etc). The name must be exactly ".gitignore" for Git to recognize it. The file must have no extension (i.e., .txt) so go ahead and delete that (don't worry about any warnings). 

Once .gitignore is created, we can start adding rules. Nothing prevents us from listing files in .gitignore one by one, but this approach is not efficient. Instead, we can use pattern matching to kill many birds with one stone. What all these files have in common is they are all either .jpg's or .docx's. We can use the wildcard '*' to signify "any character" before the file extension:

```
\*.jpg  
\*.docx  
```

This will exclude any .jpg or .docx file from being tracked by Git in this repository. Since the images are conveniently located all together in one folder, we can also just do this:

```
figures/
```

We should also add the following rules to ignore the user-specific R project files:

```
\*.Rhistory   
/.Rproj.user/  
```
We can add as many rules as we like, then save the .gitignore text file when we're done. Now, if we didn't forget to include anything that needed to be ignored, we can safely add all our files in one go:

```{bash, eval = F}
git add --all
```

### Committing files

Now that our files are staged, we are ready to send them to the local repository. This is called committing. Each commit is a snapshot of what the repository looked like at the time it was committed. When you commit a file, you save that version forever and will be able to go back to it. Remember, this is many steps beyond clicking "Save" on your script - you should commit a file when you feel you have made significant changes that you might want to go back to (or undo). 

For our first commit, we use the following command: 

```{bash, eval = F}
git commit -m "First commit"
```

Each commit should be accompanied by a message, added with the flag -m. The message should describe the changes made to the file/s since the previous commit. It is a good habit to write detailed commit messages, so that when we need to go back and recover a previous version of a file, you can read the history of commits and easily find the version we are looking for. 

When you next edit any of these files, you will need to repeat this process: move it to the staging area and commit those changes.

## Un-staging files

Staging initially seems like an annoying extra step, but it serves as a good check on your process before you commit something (because committing is permanent!). The following command un-stages files and saves us from having to commit them:

```{bash, eval = F}
git rm --cached filename
```

You can use pattern matching here as well, but you'll need to put a backslash in front of the wildcard:

```{bash, eval = F}
git rm --cached \*.jpg
```

In both of these cases, you probably then want to add the file names or extensions to your .gitignore file.

## Using Git with GUIs

We just learned how to use Git the hard way. Two common GUIs can make this process easier to visualize, though they provide fewer advanced functions. One is even built into RStudio.

### RStudio

RStudio integrates Git with projects. Luckily, we already created a project for this class. If you followed the instructions above, when you open that project, you will probably already see a "Git" tab in your "Environment" panel in RStudio.

### GitHub Desktop

## Exercise
