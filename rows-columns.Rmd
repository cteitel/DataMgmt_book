# Data Manipulation with R, Part 1 {#filter-select-mutate}

Much of this lesson draws from The Carpentries' [Data Analysis and Visualization in R for Ecologists](https://datacarpentry.github.io/R-ecology-lesson/index.html) workshop, which is published under a [CC-BY 4.0](https://datacarpentry.github.io/R-ecology-lesson/LICENSE.html) license.

## Objectives

* Explore the structure and content of data frames
* Understand vector types and missing data
* Use vectors as function arguments
* Understand how R assigns values to objects

## Additional reading

Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. R for Data Science (2e). Chapter 3: Data transformation, sections 3.1-3.4. Available: https://r4ds.hadley.nz/data-transform.html

## Murray, Sanchez et al. data

So far, we have used data built into R, and practiced loading data from **URLs** and **files**. In this lesson, we will go back to the data from Murray, Sanchez, et al., which is a meta-analysis of relationships between urbanization and wildlife health.


```{r}
library(tidyverse)
urban_data <- read_csv("data/raw/Murray-Sanchez_urban-wildlife.csv")
```

<!-- This help page shows you that `complete` is a function in the `tidyr` package *and* data in the `ratdat` package. This can complicate things at times, because R will use a different one by default depending on the order in which you loaded the packages. So, we can assign `ratdat`'s `complete` to an object with a new name to simplify things. We can also use the double colons `::` to specify the package from which we want to pull the object. -->

<!-- ```{r} -->
<!-- ?ratdat::complete -->
<!-- rd_complete <- ratdat::complete -->
<!-- head(rd_complete) -->
<!-- dim(rd_complete) -->
<!-- ``` -->

## Filtering rows; creating and selecting columns

One of the most important skills for working with data in R is the ability to manipulate, modify, and reshape data. The `dplyr` and `tidyr` packages in the `tidyverse` provide some very useful functions for many common data manipulation tasks.

### Selecting columns with `select()`

The `select` function allows you to take only some some columns from your data frame. The first argument is the name of the data frame, and the following arguments are the names of the columns you want. Here, we will take only species information and record IDs from the Murray et al. dataset:

```{r}
urban_species <- select(urban_data, study, host.class, aqterr, host.species)
head(urban_species)
dim(urban_species)
```

This function can be especially useful to clean up your data, for example when you have created intermediate columns, or when you read in a data set that has a lot of extraneous information. Notice that columns are now reordered: `host.species` was specified last within `select`, so it is now the last column.

We can also use `select` to remove columns, using the - symbol.

```{r}
select(urban_data, -TITLE, -AUTHORS, -YEAR, -JOURNAL)
```

`select()` also works with numeric vectors for the order of the columns. To select the 3rd, 4th, 5th, and 10th columns, we could run the following code:

```{r}
select(urban_data, 3:5, 10)
```

You should be careful when using this method, since you are being less explicit about which columns you want. However, it can be useful if you have a data frame with many columns and you don’t want to type out too many names.

We can also select columns based on their properties using the `where()` function. For example, to select all character columns:

```{r}
select(urban_data, where(is.character))
```

### Subsetting data with `filter()`

The `filter()` function subsets a data frame to rows that meet some criteria. For example, to get all rows where the taxon sampled was a bird:

```{r}
filter(urban_data, host.class == "birds")
```

Now we are introducing logical statements with the `==` sign! `==` means "is equal to". It is very different from `=`, which specifies arguments in functions (and can be used as an assignment operator, but that is not recommended). A few other useful operators and functions for filtering are:

* `!=`, which means "not equal to." `!` means "not" and can be applied to many logical statements.
* `%in%`, which asks if the left hand side is found anywhere in the vector on the right side.
* `is.na`, which asks if the value is missing.
* `>`, `>=`, `<`, and `<=`, which filter based on the values of numeric columns.

```{r}
filter(urban_data, host.class != "mammals")
filter(urban_data, host.class %in% c("birds","fish"))
filter(urban_data, is.na(pval))
filter(urban_data, YEAR >= 2010)
```

We can also filter using multiple criteria simultaneously using `&` (AND) and `|` (OR):

```{r}
filter(urban_data, host.class != "mammals" & !is.na(pval))
filter(urban_data, ptype == "Prevalence" | SAMPLE_SIZE > 100)
```

Can you describe what is being included and excluded in each of these statements?

Use the `urban_data` data to make a data frame with data from 2000 through 2010.

```{r}
```

### Making new columns with `mutate()`

Another common task is making new columns using values in existing columns. For example, we we can create a new column that measures gross domestic product (GDP, the `gdpbill` column) length in tens of billions instead of billions of dollars:

```{r}
urban_data <- mutate(urban_data, gdpbill10 = gdpbill/10)
```

`mutate` can also create multiple columns at once, separated by a comma:

```{r}
urban_data <- mutate(urban_data, gdpbill10 = gdpbill10/10,
                      years_since_1998 = YEAR - 1998) #not the best column name - a little long
# To view the new columns, we will select them, 
# because this data frame has too many columns to print them all
# and our new columns are placed at the end
select(urban_data, gdpbill, gdpbill10, YEAR, years_since_1998)
```

We can also use `mutate` to modify values in existing columns. For example, we see that the transmission mode columns are coded as integers instead of logical:

```{r}
unique(urban_data$close)
```

To replace `1`s with `TRUE`s and `0`s with `FALSE`s, we can use the `as.logical` function:

```{r}
urban_data_close <- mutate(urban_data, close = as.logical(close))
unique(urban_data_close$close)
```

Note that this works because R assumes by default that `0` means `FALSE` and `1` means `TRUE.` We will get into `if` and `ifelse` statements later, which would allow you to convert more types of values. Another way to do the same thing would be using a logical statement:

```{r}
urban_data_lgl <- mutate(urban_data, nonclose = (nonclose == 1))
unique(urban_data_lgl$nonclose)
```

As with `filter`, we can use `mutate` to create multiple columns at once:

```{r}
urban_data_lgl2 <- mutate(urban_data, close = as.logical(close),
                      nonclose = as.logical(nonclose))
```

Finally, we can also apply exactly the same function to multiple columns:

```{r}
urban_data_lgl <- mutate(urban_data, across(c(close, nonclose, vector, intermediate), as.logical))
```

Note that this is a little more complicated! The first argument is still the data set (`urban_data`), but the second argument is now a vector of column names, enclosed within `c()`, and the function `across` applies the function to multiple columns. The second argument to `across` is the function that is applied to all the columns.

Another common task is to replace NAs with another value, or to replace certain character strings (e.g., `""`) with `NA`s. For example, for studies with no difference in urbanization across the study area (the `udiff_1000` column), we might want to replace `0` with a missing value. Here, we can use a combination of `mutate` with the `na_if` function from `tidyr`:

```{r}
mutate(urban_data, udiff_1000 = na_if(udiff_1000, 0))
```

Finally, a very useful function for creating new columns is `if_else()` (or the base R version, `ifelse`). This is a simplified version of the `if` statements that we will learn about later in the class. Again makes a vector as a function of another vector, this time conditionally. I provide a conditional statement ("if") and an alternative ("else"). The example above is essentially a streamlined ifelse function; the following code does the same thing:

```{r}
mutate(urban_data, udiff_1000 = if_else(udiff_1000 == 0, NA, udiff_1000))
```

Here, the first argument is the condition: I am asking whether `udiff_1000` is equal to zero. The second argument is the output if the condition is true: in this place I would like the function to return `NA`. The second argument is the output if the condition is false: in this case I would like it to return the original value of the vector/column, i.e., `udiff_1000`.

Some simpler examples:

```{r}
# Create a vector
species <- c("elephant", "snow leopard", "indian leopard", "sloth bear", "bengal tiger")
# Check whether these animals are cats
if_else(species %in% c("snow leopard", "indian leopard", "bengal tiger"), "cat" , "not a cat")

# Create a vector
nums <- c(50, 194, 281, 92)
# Check if each element is even or odd
if_else(nums %% 2 == 0,"even","odd")
```

Notice that here, `%%` returns the remainder of a division, so numbers divided by two with a remainder of zero are even.

The main difference between the `tidyverse's` `if_else` and base R's `ifelse` is that `if_else` preserves factor levels and other types (for example, dates, which we will learn about soon).

```{r}
# Unlike `ifelse()`, `if_else()` preserves types
# This example comes from the help page for if_else
x <- factor(c("a", "i", "e", "f", "g", "c", "i", "b"))
ifelse(x %in% c("a", "b", "c"), x, NA)
if_else(x %in% c("a", "b", "c"), x, NA)
```

## Pipes

What if you want to do a bunch of operations in order, for example filtering your data and creating new columns. The most basic way to do this is to create intermediate objects:

```{r}
urban_data_mamm <- filter(urban_data, host.class == "mammals")
urban_data_mamm <- mutate(urban_data_mamm, across(c(close, nonclose, vector, intermediate), as.logical))
```

You could also nest your functions, but as you can see this gets unwieldy quickly:

```{r}
urban_data_mamm <- filter(mutate(urban_data_mamm, across(c(close, nonclose, vector, intermediate), as.logical)), host.class == "mammals")
```

`tidyverse` provides a powerful way to tie a squence of actions together: the pipe (`%>%`). Pipes can initially be intimidating (what are those `%` doing?!) and they are by no means necessary to use, but they can make your code neat and easier to understand. 

```{r}
urban_data_mamm <- urban_data %>%
  filter(host.class == "mammals") %>%
  mutate(across(c(close, nonclose, vector, intermediate), as.logical))
```

You can read the pipe as *then*: take the urban data, *then* take only rows for mammals, *then* convert the transmission mode columns to logical. The pipe takes the output of the previous line and feeds it as input into the next one. Notice that you don't have to repeat the name of the data object,because the data is whatever the pipe is feeding into the function. There are 
several advantages to using pipes compared to traditional syntax. First, by 
using a pipe in the example above, we avoided saving intermediate objects (e.g., 
`no_pkey`) to the environment: we only saved the final result we wanted. Second,
we typed less. Third, our code is more readable because the syntax of our code
reflects the logical structure of what we are doing. The shortcut for inserting a pipe
is `Ctrl + Shift + M` on Windows and `Cmd + Shift + M` on Mac.



